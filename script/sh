#!perl
#: sh
#: Perl simulator for /bin/sh (Bourne Shell)
#: 2006-02-01 2006-02-02

use strict;
use warnings;

use Getopt::Std;
use Text::Balanced qw( extract_delimited extract_multiple );
use Data::Dumper::Simple;
use Time::HiRes qw( sleep );

{
    my %opts;
    getopts('c', \%opts);

    my $cmd = join(' ', @ARGV);
    #warn Dumper($cmd);

    $cmd =~ s/\n+/ /gs;
    my @raw_args = split_arg($cmd);
    exit(0) if ! @raw_args;

    my @args = process_args(0, @raw_args);
    exit eval_cmd(@args);
}

sub split_arg {
    my $text = shift;
    return () if not defined $text;
    my $escape_pat = gen_escape_pat( q{ ' " # \\ \ } );
    my @flds = extract_multiple(
        $text,
        [
            qr/\G\s*$escape_pat+/,
            sub { extract_delimited($_[0], q{"}) },
            qr/\G\s*'[^']*'/,
            qr/\G\s*\S[^'"\s]*/,
        ],
        undef,
        1,
    );
    @flds = grep { s/^\s+|\s+$//g; defined($_) && $_ ne '' } @flds;
    #warn "\n======================\n";
    #warn Dumper($text, @flds);
    #warn "======================\n";
    return @flds;
}

sub process_args {
    #warn "!!!!!!!!!!!!!!!!!!!!!!";
    my $level = shift;
    my @raw_args = @_;
    my @args;
    foreach (@raw_args) {
        #warn "----------\n";
        #warn Dumper(@args, $_, @raw_args);
        #warn "----------\n";
        if (/^"(.*)"$/) {
            #warn "---------";
            #warn qq{Pusing "$1" into args\n};
            my $s = $1;
            process_escape( $s, q{ " \\ @ $ # } );
            push @args, $s if $s ne '';
        } elsif (/^'(.*)'$/) {
            #warn "  Pusing '$1' into args\n";
            push @args, $1 if $1 ne '';
        } elsif (/^['"]/) {
            die "sh: unexpected EOF while looking for matching `$&'\n";
        } else {
            #warn "  Remaining: $_\n";
            my $s = $_;
            if ($level == 0 and $s =~ /^\#/) {
                return @args;
            }
            process_unquoted($s, $level, \@args);
            #warn "~~~~~~~~~~~~~~\n";
            #warn Dumper(@args, $_, @raw_args);
            #warn "~~~~~~~~~~~~~~\n";
        }
    }
    return @args;
}

sub process_unquoted {
    my ($s, $level, $rargs) = @_;
    return if $s eq '';
    my $other;
    if ($level == 0 and $s =~ /(.*);(.*)/) {
        $s = $1;
        $other = $2;
    }
    process_escape( $s, q{ ' " # \\ \ } );
    my @subargs = split_arg($s) if $s =~ / /;
    #warn Dumper(@subargs);
    if (@subargs > 1) {
        push @$rargs, process_args ($level+1, @subargs);
    } else {
        my @files = glob $s;
        if (@files > 1) {
            push @$rargs, @files;
        } else {
            push @$rargs, $s if $s ne '';
        }
    }
    if (defined $other) {
        #warn "^^^^^^^^^^^^^\n";
        #warn Dumper($rargs, $other);
        #warn "^^^^^^^^^^^^^\n";
        eval_cmd(@$rargs);
        @$rargs = ();
        #process_unquoted($other, $level, $rargs);
    }
}

sub process_escape {
    my $pat = gen_escape_pat($_[1]);
    $_[0] =~ s/$pat/substr($&,1,1)/eg;
}

sub gen_escape_pat {
    my $list = quotemeta $_[0];
    return qr/ \\ [ $list ] /x;
}

sub subs_env {
    $_[0] =~ s/\$(\w+)/defined $ENV{$1} ? "$ENV{$1}" : ''/ge;
}

sub eval_cmd {
    my @args = @_;
    map { subs_env($_) } @args;
    my $exec = shift @args;
    #warn Dumper($exec, @args);
    if ($exec eq 'echo') {
        print "@args\n";
        return 0;
    } elsif ($exec eq 'rm') {
        foreach my $file (@args) {
            $file =~ s/\s+$//;
            if (! -e $file) {
                warn "rm: cannot lstat `$file': No such file or directory\n";
                return 1;
            }
            unlink $file;
        }
        return 0;
    } elsif ($exec eq 'sleep') {
        sleep ($args[0]);
    } else {
        warn "sh: unknown shell command: $exec";
        return 254;
    }
}
