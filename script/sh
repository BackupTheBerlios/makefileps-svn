#!perl
#: sh
#: Perl simulator for /bin/sh (Bourne Shell)
#: 2006-02-01 2006-02-03

use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/..";
use t::Util::Base;

use Getopt::Std;
#use Data::Dumper::Simple;
use Time::HiRes qw( sleep );

my %opts;
getopts('c', \%opts);

my $ExitCode = 0;

$| = 1;

if ($opts{c}) {
    eval {
        process_shell(join ' ', @ARGV);
    };
    warn $@ if $@;
    exit($ExitCode);
} else {
    print '$ ';
    process_prompt();
    exit(0);
}

sub process_prompt {
    while (<STDIN>) {
        chomp;
        #warn "Got shell [$_]";
        last if /^\s*exit\s*$/;
        eval {
            process_shell($_);
        };
        if ($@) {
            warn "$@\n";
            warn "[Error code $ExitCode returned.]\n";
        }
        print '$ ';
    }
}

sub process_shell {
    my $cmd = shift;
    #warn Dumper($cmd);

    $cmd =~ s/\n+/ /gs;
    my @raw_args = split_arg($cmd);
    my @args = process_args(0, @raw_args);
    return eval_cmd(@args);
}

sub process_args ($$) {
    #warn "!!!!!!!!!!!!!!!!!!!!!!";
    my $level = shift;
    my @raw_args = @_;
    my @args;
    foreach (@raw_args) {
        #warn "----------\n";
        #warn Dumper(@args, $_, @raw_args);
        #warn "----------\n";
        if (/^"(.*)"$/) {
            #warn "---------";
            #warn qq{Pusing "$1" into args\n};
            my $s = $1;
            process_escape( $s, q{ " \\ @ $ # } );
            subs_env($s);
            push @args, $s if $s ne '';
        } elsif (/^'(.*)'$/) {
            #warn "  Pusing '$1' into args\n";
            push @args, $1 if $1 ne '';
        } elsif (/^['"]/) {
            $ExitCode = 1;
            die "sh: unexpected EOF while looking for matching `$&'\n";
        } else {
            #warn "  Remaining: $_\n";
            my $s = $_;
            if ($level == 0 and $s =~ /^\#/) {
                return @args;
            }
            $s =~ s/\\(.)/$1/gs;
            process_unquoted($s, $level, \@args);
            #warn "~~~~~~~~~~~~~~\n";
            #warn Dumper(@args, $_, @raw_args);
            #warn "~~~~~~~~~~~~~~\n";
        }
    }
    return @args;
}

sub process_unquoted {
    my ($s, $level, $rargs) = @_;
    return if $s eq '';
    my $other;
    if ($level == 0 and $s =~ /(.*);(.*)/) {
        $s = $1;
        $other = $2;
    }
    subs_env($s);
    my @subargs = split_arg($s) if $s =~ / /;
    #warn Dumper(@subargs);
    if (@subargs > 1) {
        push @$rargs, process_args ($level+1, @subargs);
    } else {
        my @files = glob $s;
        if (@files > 1) {
            push @$rargs, @files;
        } else {
            push @$rargs, $s if $s ne '';
        }
    }
    if (defined $other) {
        #warn "^^^^^^^^^^^^^\n";
        #warn Dumper($rargs, $other);
        #warn "^^^^^^^^^^^^^\n";
        eval_cmd(@$rargs);
        @$rargs = ();
        #process_unquoted($other, $level, $rargs);
    }
}

sub subs_env {
    $_[0] =~ s/\$(\w+)/defined $ENV{$1} ? "$ENV{$1}" : ''/ge;
}

sub eval_cmd {
    my @args = @_;
    return 0 if not @args;
    my $exec = shift @args;
    #warn Dumper($exec, @args);
    if ($exec eq 'echo') {
        print "@args\n";
        return 0;
    } elsif ($exec eq 'rm') {
        foreach my $file (@args) {
            $file =~ s/\s+$//;
            if (! -e $file) {
                warn "rm: cannot lstat `$file': No such file or directory\n";
                $ExitCode = 1;
                return;
            }
            unlink $file;
        }
        return 0;
    } elsif ($exec eq 'sleep') {
        sleep ($args[0]);
    } elsif ($exec eq 'pwd') {
        require 'Cwd.pm';
        print Cwd::cwd(), "\n";
    } elsif ($exec eq 'cd') {
        chdir $args[0];
    } else {
        warn "sh: unknown shell command: $exec";
        $ExitCode = 1;
        return;
    }
}
